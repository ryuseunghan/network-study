# Chapter 4 네트워크 계층

##  해당 챕터의 글에서 IP 주소는 정확히는 주소 개념과 다를 수 있지만, 이해하기 쉽게 편의상 '주소'라고 표현하겠습니다. 😊




<br>
<br>
<br>
<br>
<br>




> 네트워크 계층이란 ?

지난 챕터에서 이더넷이나 무선 LAN으로 만들어진 **네트워크**들을 연결해서 큰 규모의 네트워크를 만드는 계층입니다.

네트워크 계층에서는 대부분 IPv4,IPv6 두 가지 버전의 프로토콜을 사용합니다.

## 4.1 IPv4

1981년에 발행된 커넥션리스 타입 프로토콜입니다.
어떤 포맷으로 데이터를 캡슐화하고,구성하는 필드가 어떤 기능을 갖는지 정의합니다.

> "커넥션리스(Connectionless)"란?
>
"패킷을 보낼 때, 미리 연결을 설정하지 않고 바로 전송하는 방식"

### IPv4의 패킷 포맷

IP에 의해 캡슐화되는 패킷을 **IP 패킷**이라고 부릅니다.
IP 패킷은 **헤더**와, **페이로드**로 구성되어 있습니다.

### IPv4 패킷 헤더

![Image](https://github.com/user-attachments/assets/ccd5f38b-1bc8-48f6-bc69-e7dca2a2ea90)


- **버전**
    - 버전은 이름 그대로 IP의 버전을 나타내는 4비트 필드입니다.
- **헤더 길이**
    - 헤더길이는 IPv4의 헤더의 길이를 나타내는 4비트 필드입니다.
    - 이 값을 보고 수신단말이 어디까지 IPv4 헤더인지 식별합니다.
    - 헤더 길이는 4바이트 단위로 값이 들어갑니다.
        - ex) 20byte => '5'가 들어감.(헤더 길이의 최소값은 20byte)
- **ToS** (Type Of Service)
    - Ipv4 패킷의 우선도를 나타내는 1바이트 필드입니다.
    - **DSCP** (우선 제어, 대역 제어)
        - ![Image](https://github.com/user-attachments/assets/a0ece5fd-f096-4394-82c8-4d99d9b50598)
        - **BE** (Best Effort, 000000)
            - 특별한 QoS 적용 없이 기본 처리됨.
                - 웹 브라우징, 이메일과 같은 일반 트래픽에 사용됨.
        - **EF** (Expedited Forwarding, 101110)
            - 최우선(priority) 처리가 필요함.
            - `실시간 트래픽(음성 통화, 온라인 게임)`에 사용
        - **AF** (Assured Forwarding, 001010)
            - 특정 그래픽을 보장하지만,EF보다는 낮은 우선순위를 가짐.
            - 스트리밍, 금융 거래, 기업 내부 데이터 전송 등에 사용됨.
    - **ECN** (혼잡 제어)
    - 의미 설명  <br>
      00 No ECN ECN 미사용 <br>
      01 ECN Capable Transport (ECT1)    ECN 사용 가능 <br>
      10 ECN Capable Transport (ECT0)    ECN 사용 가능 <br>
      11 Congestion Experienced (CE)    네트워크 혼잡 발생 (라우터가 혼잡 상태임을 표시) <br>
    - 라우터가 혼잡을 감지하면 CE로 설정해서 수신자가 혼잡 상태임을 알게 만듦.
- **패킷 길이**
    - 패킷 길이는 IPv4의 헤더와 페이로드를 합친 전체의 길이를 나타내는 것입니다.
- **식별자**
    - 패킷 교환 방식에서는 데이터를 MTU까지만 IP 패키지에 저장이 가능합니다. ( 소포 무게 재한때문에, 분할해서 보내야 하는 경우)
    - 이때, 데이터를 송신하기 쉽도록 작게 나누는데, 이를 **IP 프래그멘테이션**이라고 부릅니다. 그리고 이때 분할되는 프래그멘테이션들에게 같은 식별자를 부여해 수신 단말에서 패킷을 재결합합니다.
- **플래그**
  - 3비트로 구성된 플래그 비트셋
  - 1번 비트 사용 X
  - 2번 비트 **DF** 
    - IP 패킷을 프래그멘테이션 해도 좋은지를 구분함.
  - 3번 비트 **MF**
    - 프래그멘테이션된 패킷이 뒤에 계속되는가를 나타냄.
    - 0이면 뒤에 더이상 오지않는 것, 1이면 뒤에 계속 오는것이다
- 프래그먼트 오프셋

![Image](https://github.com/user-attachments/assets/43aa7cb4-2833-440d-836d-ef49836151eb)
  - 프래그멘테이션 한 뒤, 패킷이 오리지널 패킷으로부터 어느 위치에 있는지를 나타내는 필드.
  - 해당 필드는 8byte 단위로 저장됨.
  - 예시: 4000바이트짜리 패킷이 MTU(1500바이트) 제한으로 인해 조각화되는 경우
  - | 조각 번호 | 데이터 크기 | Fragment Offset (8바이트 단위) |
    |---------|---------|----------------------|
    | **1번 조각** | 1480바이트 (헤더 20바이트 제외) | 0 (0×8 = 0바이트 위치부터 시작) |
    | **2번 조각** | 1480바이트 | 185 (185×8 = 1480바이트부터 시작) |
    | **3번 조각** | 1040바이트 | 370 (370×8 = 2960바이트부터 시작) |
- **TTL**
  ![Image](https://github.com/user-attachments/assets/c53f2a8a-ca36-45c8-94fe-6580ffd9fee1)
  - 패킷의 수명을 나타내는 1바이트 필드입니다. IP 세게에서는 IP 패킷의 수명은 '경유하는 라우터의 수'를 의미합니다.
  - 경유하는 라우터의 수를 `홉(hop) 수`라 부르고, 네트워크를 경유할 때마다 1씩 감소합니다.
- **프로토콜 번호**
  - IPv4 페이로드가 어던 프로토콜로 구성되어 있는지를 나타내는 1바이트 필드입니다.
  - | 번호      | 프로토콜              | 설명 |
    |---------|-------------------|------|
    | **1**   | **ICMP**              | 인터넷 제어 메시지 프로토콜 (Ping, 네트워크 오류 보고) |
    | **2**   | IGMP              | 인터넷 그룹 관리 프로토콜 (멀티캐스트 관리) |
    | **6**   | **TCP**               | 신뢰성 있는 전송 제어 프로토콜 |
    | **17**  | **UDP**               | 비연결형 사용자 데이터그램 프로토콜 |
    | **41**  | IPv6 encapsulation | IPv6 패킷을 IPv4 내에서 캡슐화 |
    | **47**  | GRE               | 일반 라우팅 캡슐화 (VPN, 터널링) |
    | **50**  | ESP               | IPsec의 암호화 보안 프로토콜 |
    | **51**  | AH                | IPsec 인증 헤더 |
    | **58**  | ICMPv6            | IPv6용 인터넷 제어 메시지 프로토콜 |
    | **89**  | OSPF              | 개방형 최단 경로 우선 프로토콜 (라우팅) |
    | **112** | VRRP              | 트워크에서 라우터의 장애에 대비해 백업 라우터를 자동으로 전환하는 프로토콜입니다. |
- **헤더 체크섬**<br>
  ![Image](https://github.com/user-attachments/assets/f1f5f6bc-10c2-4af2-be1d-514e58ca79b9)
  - IPv4 헤더의 정합성을 체크하기 위해 사용되는 필드입니다.
  - 1의 보수 연산 방법을 채용하고 있습니다.
  - 16비트 단위로 나누어 모든 값을 더하고, 오버플로우 발생 시, 상위 비트를 다시 더함. 결과를 1의 보수로 변환.
  - ``` yaml
     0111 0100 0100 1110  (원래 값: 0x744E) 
     1000 1011 1011 0001  (1의 보수: 0x8BB1) 
    ```
- **⭐송신지/수신지 IPv4 주소⭐**
![Image](https://github.com/user-attachments/assets/e05959fa-61e7-4cbb-a939-a35d0ee22274)
  - 단말 하나당 여러개의 IP를 가질 수 있습니다.
      - ex) 라우터는 IP 네트워크를 연결하기 위해, 포트마다 IP 주소를 가지고 있습니다.
- **패딩**
  - IPv4 헤더의 비트 수를 정렬하기 위해 사용되는 필드.
  - 항상 4byte 단위여야 하기 때문에, 4바이트의 정수 배가 되지 않으면 마지막에 패딩 '0'을 추가해 정수배로 만듭니다.

### 4.1.2 IPv4 주소와 서브넷 마스크
IP 헤더 중 가장 중요한 필드가 송신지 IP 주소와  수신지 IP 주소입니다.
- IP 주소는 **32비트**로 구성되어 있음.
- 8바이트씩 점으로 구분해서 10진수로 표기함.
  - ex) **172.16.1.1**
- 점으로 구분한 그룹을 **옥텟이라** 부른다.


> **서브넷 마스크**

IPv4 주소는 그 자체로 사용하지 않는다. 
- IPv4 주소는 한정된 개수(약 43억 개)만 존재하기 때문
- **네트워크 부분**과 **호스트 부분**으로 구성되어 있다.
  - 네트워크 부분은 어떤 IPv4 네트워크에 있는가를 나타낸다.
  - 호스트 부분은 어떤 단말인가를 나타낸다.<br>
    ![Image](https://github.com/user-attachments/assets/907036d7-13ae-46e7-a5e1-17891c48a3c6)

> **10진수 표기와 CIDR 표기**

서브넷 마스크에는 10진수 표기와 CIDR 표기 2종류 표기 방법이 있다.
- 10진수 표기는 IPv4 주소와 같이 32비트를 4개씩 그룹으로 나눠, 10진수로 변환하고 점으로 구분해서 표기한다.
- CIDR 표기는 IPv4 주소 뒤에 '/'와 서브넷 마스크의 '1'의 비트 수를 표기합니다.<br>
  ![Image](https://github.com/user-attachments/assets/6c415777-b303-4856-964c-9097d720b584)
- 예를들어, 192.168.10.1이라는 주소에 255.255.255.0 이라는 서브넷 마스크가 설정된 경우, CIDR 표기에서는 192.168.10.1/24가 됩니다.
- 어떤 값이 오더라도 네트워크 부분이 192.168.10이므로 호스트 부분이 1인 것을 알 수 있습니다.


### 4.1.3 다양한 IPv4 주소

> **사용 용도에 따른 분류**

- IPv4 주소는 사용 용도에 따라 클래스 A~E까지 3개 주소 그룹으로 분류할 수 있습니다.
- 일반적으로 A부터 C까지만 사용됩니다.
- 이 주소들은 유니캐스트에 사용됩니다. 
- 이 3개의 클래스의 차이는 네트워크 규모의 차이입니다.
  - D 클래스는 멀티캐스트
  - E 클래스는 예약되어있는 클래스입니다.

 | 클래스 | 용도 | 시작 비트 | 시작 IP 주소 | 종료 IP 주소 | 네트워크 부분 | 호스트 부분 | 최대 할당 가능 IP 주소 수 |
  |--------|------|----------|--------------|--------------|--------------|------------|----------------------|
  | **A** | 대규모 네트워크 (ISP, 대기업) | `0xxxxxxx` (0~127) | 1.0.0.0 | 126.255.255.255 | 8비트 | 24비트 | 16,777,214 개 |
  | **B** | 중간 규모 네트워크 (대학, 기업) | `10xxxxxx` (128~191) | 128.0.0.0 | 191.255.255.255 | 16비트 | 16비트 | 65,534 개 |
  | **C** | 소규모 네트워크 (소규모 기업, 가정) | `110xxxxx` (192~223) | 192.0.0.0 | 223.255.255.255 | 24비트 | 8비트 | 254 개 |
  | **D** | 멀티캐스트 주소 | `1110xxxx` (224~239) | 224.0.0.0 | 239.255.255.255 | 없음 | 없음 | N/A (멀티캐스트 전용) |
  | **E** | 연구 및 실험용 | `1111xxxx` (240~255) | 240.0.0.0 | 255.255.255.255 | 없음 | 없음 | N/A (예약됨) |



📌 클래스풀 어드레싱

주소 클래스에 기반해 IPv4 주소를 할당하는 방식을 말합니다.
- 주소 클래스 규모가 고정적이어서 낭비되는 주소가 많다는 단점이 있습니다. => 클래스리스 어드레싱

📌 클래스리스 어드레싱

주소 클래스에 관게없이 IPv4 주소를 할당하는 방식을 클래스리스 어드레싱이라 부릅니다. (CIDR)
- 클래스리스 어드레싱은 유한한 IP 주소를 유효하게 활용할 수 있기 때문에 현재 할당 방식의 주류가 되었습니다.
![Image](https://github.com/user-attachments/assets/b8f0ffee-52bc-4793-a355-4a1a19c8c775)

<br><br><br>
  
> 사용 장소에 따른 분류

사용 장소 : 네트워크에 있어서의 논리적인 장소
- `글로벌 IPv4(퍼블릭 IPv4)`와 `프라이빗 IPv4주소`로 분류됩니다.

📌 글로벌 IPv4 주소
IANA와 그 하부 조직이 해당 주소를 관리중이며,
자유롭게 할당할 수 없는 IPv4주소입니다. 글로벌 IPv4 주소는 현재 그 남은 숫자가 부족해서 최근에는 할당에 제한이 있는것으로 보입니다.

📌 프라이빗 IPv4 주소
조직 안에서 자유롭게 할당할 수 있는 IPv4 주소입니다. 주소 클래스별로 정의되어 있습니다.
- 예시, 가정에서 사용하는 192.168.x.x -> 클래스 C로 정의된 프라이빗 IPv4 주소

📌 프라이빗 IPv4 주소는 외부와 어떻게 통신??
프라이빗 IPv4 주소는 조직내에서만 유효합니다. 인터넷에 접속이 필요할때는 프라이빗 IPv4 주소를 글로벌 IPv4 주소로 변환해야 합니다.
이 기능을 `NAT`라 부릅니다.  

![Image](https://github.com/user-attachments/assets/87ac3818-f363-4f40-99f4-7d8485952cdd)
<br><br>

📌 NAT란?
```plaintext
1️⃣ 한 회사(사설 네트워크)에 직원들(사설 IP 주소)이 여러 명 있음.
2️⃣ 하지만 회사 밖(인터넷)에서는 하나의 대표 전화번호(공인 IP)만 알 수 있음.
3️⃣ 직원이 외부로 전화를 걸면, 전화 교환원(NAT)이 회사 대표 번호로 변환해 상대방에게 전달함.
4️⃣ 외부에서 전화가 오면, 교환원(NAT)이 누구에게 연결해야 하는지 내부 시스템을 통해 찾아줌.

💡 즉, NAT는 하나의 공인 IP 주소를 사용해 여러 내부 장치(사설 IP)를 인터넷과 연결해주는 역할을 합니다. (자세한 내용은 203p 확인)
```

<br><br><br>


> 예외 주소

- 특별한 용도로 사용되기 때문에 설정할 수 없는 특수한 주소가 존재합니다.


📌 네트워크 주소

- 네트워크 주소는 호스트 부분의 비트가 모두 '0'인 IP 주소이다. 해당 네트워크 자체를 의미합니다.
![Image](https://github.com/user-attachments/assets/1131ac15-98d0-4c22-814a-209d83f6d8c1)

📌 기본 경로 주소

- 네트워크 주소를 최대한으로 설정해 IPv4 주소, 서브넷 마스크를 모두 '0'으로 설정한 '0.0.0.0/0'은 기본경로주소가 됩니다.
  - -> 기본 경로 주소는 '모든 네트워크'를 나타냅니다.
  - -> 0.0.0.0에 데이터 전송해 == 모든 네트워크에 데이터 전송해

![Image](https://github.com/user-attachments/assets/c0008db8-580e-4100-9138-7075b01f3234)



📌 브로드캐스트 주소

- 브로드캐스트 주소는 호스트 부분의 비트가 모두 '1'인 IPv4 주소이며 같은 네트워크에 존재하는 모든 단말을 나타냅니다.
- 192.169.100.1의 주소의 브로드캐스트 주소는? 192.169.100.255 C 클래스 주소이므로, 네트워크 부분은 하위 8 bit이 모두 1
![Image](https://github.com/user-attachments/assets/add851a5-cf12-4170-ab7f-81bb1ebd6961)

> **브로드 캐스트 주소**를 최대한으로 설정해 모든 비트를 1로 설정한 `255.255.255.255/32`는 `리미티드 브로드캐스트 주소`라고 부릅니다. <br>
> 해당 주소로 통신을 시도하면 브로드캐스트 주소와 동일하게 동작합니다. <br>
> `리미티드 브로드 캐스트`는  자신의 주소를 모르거나 네트워크 주소를 알 수 없을 때 사용됩니다.

<br><br><br>


📌 루프백 주소
- 루프백 주소는 자기 자신을 나타내는 IPv4 주소입니다.
- 127.0.0.1/8을 통상 사용합니다.

![Image](https://github.com/user-attachments/assets/bfef5bbb-6aee-452c-ab5a-afad2d8fd33e)




## IPv6
- IPv4와 달리 IPv6 주소는 2¹²⁸ 개까지 할당할 수 있습니다. 
- IPv4의 고갈을 대비하기 위해 새롭게 표준화된 프로토콜입니다.


### 4.2.1 IPv6의 패킷 포맷
- IPv6  헤더는 매우 간단한 포맷을 가지고 있습니다. v4와 달리 길이가 고정되어 있고, 불필요한 필드의 종류를 줄였습니다.
- 헤더 길이와 필드 수 감소가 어떻게 달라졌을까요?

> 헤더 길이
- IPv4는 가변길이 옵션 필드가 존재해 20byte 이상의 길이를 가지지만, IPv6에서는 사용하지 않는  옵션 필드를 "확장 헤더"라는 헤더로 분리했습니다.
- 덕분에, IPv6에서는 헤더길이를 40바이트로 고정하고 있습니다. 
- 헤더길이가 고정되어 있기 때문에 받은 패킷 헤더의 길이를 굳이 조사할 필요가 없어졌다는 장점도 존재합니다.

> 필드 수 감소
- IPv6는 그림처럼 불필요한 필드를 줄여 단순함을 추구했습니다.
- 덕분에 네트워크 기기의 처리 부하가 줄고 성능이 향상됩니다.
  - 단순히 길이가 줄었을 뿐만 아니라 이에대한 체크 알고리즘또한 불필요해졌기 때문입니다.

![Image](https://github.com/user-attachments/assets/0f4c3150-633d-47ba-9f41-008cbe5f2700)

> 헤더의 필드들
- 버전
  - IP 버전을 나타내는 필드입니다.
- 트래픽 클래스
  - 패킷의 우선도를 나타내는 필드입니다. IPv4의 Tos 필드에 해당됩니다.
- 플로우 라벨
  - 통신 흐름을 식별하는 필드입니다.
  - 새롭게 추가된 필드입니다.
  - IPv4의 송신지 주소, 수신지 주소, 송신지 포트 번호, 수신지 포트 번호, L4 프로토콜을 하나로 모아 정의한 것.
- 페이로드 길이
  - 페이로드(데이터)의 길이를 나타내는 필드입니다.
  - IPv4에서는 패킷길이로 헤더와 페이로드를 합쳐 계산했지만, v6에서는 헤더길이가 고정되어 있어, 헤더의 길이를 포함할 필요 없습니다.
- 넥스트 헤더
  - IPv6헤더 바로 뒤에 이어지는 헤더를 나타내는 필드입니다.
- 홉 리미트
  - 네트워크를 이동할때마다 홉(hop)수가 감소하는걸 기억하시나요?
  - 홉 리미트는 홉 수의 상한값을 나타냅니다. 즉, 해당 패킷의 생존시간을 정의합니다.
- 송신지/수신지 수소
  - 역할은 v4와 크게 다르지 않습니다.
  - 네트워크내의 주소를 의미합니다.



### 4.2.2 IPv6 주소와 프리픽스
- IPv4, IPv6의 가장 큰 차이는 길이입니다.
- IPv6주소는 128비트나 되기떄문입니다.
  ![Image](https://github.com/user-attachments/assets/75d68388-ab75-41aa-b2a9-5c1017bf7631)
- 📌 IPv4 (32비트, 4개의 숫자 블록)
    - ✔ 숫자 4개(0~255 범위)를 .(닷)으로 구분
    - ✔ 총 32비트 (8비트 × 4 블록)
    - 🔹 예시: `192.168.0.1`

- 📌 IPv6 (128비트, 8개의 16진수 블록)
  - ✔ 16진수 숫자(0~F)를 :(콜론)으로 구분
  - ✔ 총 128비트 (16비트 × 8 블록)
  - 🔹 예시: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`



> 서브넷 프리픽스와 인터페이스 ID

IPv6 주소는 `네트워크를 식별하는 서브넷 프리픽스(subnet prefix)`와  
**단말을 식별하는 인터페이스 ID(Interface ID)** 2개로 구성됩니다.

- 서브넷 프리픽스는 IPv4 주소의 네트워크 부분에 해당
- 인터페이스 ID는 IPv4의 호스트 부분에 해당
- 서브넷 프리픽스는 **IPv4의 CIDR 표기(148쪽)처럼 '/' 이후 숫자로 표기**

예를 들어,  
`2001:db8:0:0:0:0:0:1/64` → `2001:db8:0:0::1/64`  
이 경우 네트워크에는 **`0:0:0:0`이라는 단말이 포함**됨  

---

> IPv6 주소 표기 규칙

IPv6 주소는 **128비트 길이**로 **16진수**로 표기해도 **32문자**가 됩니다.  
이를 단순화하기 위해 몇 가지 표기 규칙을 적용합니다.

### ✅ 각 필드 맨 앞의 연속된 '0' 생략 가능
- `0001` → `1`
- `0023` → `23`
- `0000` → `0`

💡 모든 필드가 `0`이면 **'0' 하나로 표기 가능**  
![Image](https://github.com/user-attachments/assets/510eb1c4-26db-43ea-be16-d39323db818c)



> **여러 필드에 걸쳐 '0'이 이어질 때 `::`으로 생략할 수 있다**

여러 필드가 연속된 `0`일 때는 **`::`으로 생략**하여 짧게 표현할 수 있습니다.  
예를 들어, `2001:db8:0000:0000:0000:0000:0000:1234`은 5개의 연속된 `0`이 포함되므로,  
`2001:db8::1234`로 간략하게 표현할 수 있습니다.
![Image](https://github.com/user-attachments/assets/0646f9e1-0abf-4d8f-93a3-ad9859029bfe)



---

> **생략은 1번만 할 수 있다**

`::`은 **하나의 IPv6 주소에서 단 한 번만 사용할 수 있습니다.**  
예를 들어,
- ❌ `2001:db8::abc0::abcd` (잘못된 표기)
- ✅ `2001:db8::abc0:abcd` (올바른 표기)

![Image](https://github.com/user-attachments/assets/80b2c5df-1988-4a5e-959a-3f4f2ba80088)

---

> **맨 앞의 단독 '0'일 때는 생략할 수 없다**

맨 앞의 `0`이 단독으로 있는 경우, **`::`으로 생략할 수 없습니다.**  
예를 들어,
- ❌ `2001:db8:1234::abcd:0:cd` (잘못된 표기)
- ✅ `2001:db8:1234::abcd:cd` (올바른 표기)

![Image](https://github.com/user-attachments/assets/00a229be-58c5-4bca-973d-5a8fdd500874)
6

---

> **가능한 한 짧게 만든다**

`::`을 사용하는 경우, **가장 많은 `0`을 포함하도록** 만들어야 합니다.  
예를 들어,
- `2001:db8:0:0:0:0:2:1` → `2001:db8::2:1`
- `2001:db8:1:0:0:0:0:1` → `2001:db8:1::1`

![Image](https://github.com/user-attachments/assets/b5c825d9-9da0-4705-bcca-999c4306c636)

---

> **가장 많이 생략할 수 있는 부분을 선택한다**

생략할 수 있는 부분이 여러 개라면 **길이가 가장 긴 부분을 우선 생략**해야 합니다.  
예를 들어,
- `2001:0:0:1:0:0:0:2`
    - 2번째 블록(0)과 4번째 블록(0)이 연속
    - `2001::1:0:0:0:2`보다 `2001:0:0:1::2`가 더 짧은 형태
    - 최적 표기법: `2001:1::2`
![Image](https://github.com/user-attachments/assets/5cd3849f-0349-40bd-902e-66e2058558e7)

---
> **생략할 수 있는 여러 위치의 길이가 같다면 가장 첫 위치에서 생략한다**

IPv6 주소에서 연속된 `0`을 생략할 때, **여러 위치가 같다면 가장 앞쪽을 우선적으로 생략**해야 합니다.  
예를 들어,
- `2001:db8:0:0:1:0:0:2`
    - 3번째, 6번째 필드에 `0`이 있음
    - **앞쪽(3번째 필드)을 우선적으로 생략**
    - 최적 표기: `2001:db8::1:0:0:2`


![Image](https://github.com/user-attachments/assets/be8620b1-07ec-4ab0-8c1c-390914d9b045)




## 📌 4.2.3 다양한 IPv6 주소

IPv6 주소는 **유니캐스트, 멀티캐스트, 애니캐스트** 3가지 유형으로 나뉩니다.  
이들은 **각각의 역할과 사용 목적이 다르며**, 특정 환경에서 효율적으로 동작하도록 설계되었습니다.

![Image](https://github.com/user-attachments/assets/8266304e-1446-4975-81ab-2fedb70c0609)

---


> **유니캐스트 주소 (1:1 통신)**

- 유니캐스트 주소는 특정 **1개의 장치와 직접 통신하는 주소**입니다.
- IPv4의 **공인 IP, 사설 IP** 개념과 유사하게, 글로벌 유니캐스트, 유니크 로컬, 링크 로컬로 나뉩니다.
  ![Image](https://github.com/user-attachments/assets/b3cd8255-b42e-4429-adf3-31c4097fc630)

> **📌 글로벌 유니캐스트 (`2000::/3`)**

- **IPv6에서 공인 IP와 같은 역할**을 함
- 인터넷에서 라우팅이 가능하며, ISP에서 할당받아 사용
- 예시: `2001:db8::/32`  


![Image](https://github.com/user-attachments/assets/e896a26a-11ac-48ac-b46c-e72fbab7b189)
> **📌 유니크 로컬 (`fc00::/7`)**

- **IPv4의 사설 IP(192.168.x.x, 10.x.x.x)와 유사**
- 외부 네트워크와 연결되지 않고 내부 네트워크에서만 사용 가능
- 예시: `fc00::/7` 또는 `fd00::/8`

![Image](https://github.com/user-attachments/assets/ba0ee2f0-b317-4044-879b-19157c9a0c0b)


> **📌 링크 로컬 (`fe80::/10`)**

- 같은 네트워크(LAN)에서만 사용되는 **자동 설정 주소**
- IPv4의 APIPA(자동 IP 할당, `169.254.x.x`)와 유사
- 기본적으로 모든 IPv6 장치는 링크 로컬 주소를 갖고 있음

![Image](https://github.com/user-attachments/assets/65d89897-7de1-48a9-bdad-1bc65a9fd71e)
- 유니캐스트 주소에는 이 외에도 특별한 주소들이 있습니다. 표를 통해 확인해봅시다!
![Image](https://github.com/user-attachments/assets/e8cb35d2-961d-4589-840f-b43952013f62)

---

> **멀티캐스트 주소 (1:N 통신)**

- 하나의 송신자가 **여러 수신자에게 동시에 데이터를 전달하는 방식**
- IPv4의 **클래스 D(224.0.0.0/4)와 유사**
- 같은 네트워크 내 특정 그룹을 지정하여 통신할 수 있음
- 예시:
    - `ff02::1` → 같은 네트워크의 모든 노드
    - `ff02::2` → 같은 네트워크의 모든 라우터

![Image](https://github.com/user-attachments/assets/d462fbc7-f35a-47d9-96bf-aa9e29fc2f1c)
---

> **애니캐스트 주소 (가장 가까운 노드와 통신)**

- 여러 개의 장치에 동일한 주소를 할당하고, **가장 가까운 장치로 패킷을 전달**
- CDN(Content Delivery Network), DNS 서버 등에 활용됨
- IPv4에는 없고 IPv6에서 새롭게 도입된 개념

![Image](https://github.com/user-attachments/assets/5f529666-cd94-4d79-b5ca-9a8147d388ac)
---


## 4.3 IP 라우팅

네트워크에서 데이터를 올바른 목적지까지 보내려면 **패킷이 어떤 경로로 이동해야 하는지**를 결정해야 합니다.  
이 과정이 바로 **IP 라우팅**이며, 이를 수행하는 장비가 `라우터(Router)`입니다.

라우팅이 없다면?  
- 👉 패킷은 목적지를 찾지 못하고 사라지거나 엉뚱한 곳으로 전달될 것입니다.  
- 👉 결국 네트워크가 작동하지 않게 됩니다.

라우팅은 `라우팅 테이블(Routing Table)`이라는 데이터를 기반으로 수행되며,  
각 네트워크 장비가 패킷을 최적의 경로로 전달할 수 있도록 도와줍니다.

---

### 4.3.1 **라우터가 IP 패킷을 라우팅하는 과정**

라우팅이 어떻게 이루어지는지 **실제 예시**를 들어 설명해보겠습니다.

#### 📌 **예제 시나리오**
- A라는 컴퓨터(192.168.1.10)가 B라는 컴퓨터(192.168.2.20)에게 데이터를 보내려 합니다.
- 하지만 A와 B는 서로 다른 네트워크(서브넷)에 있습니다.
- 따라서 A는 데이터를 직접 B에게 보낼 수 없고, **라우터(R1)가 중간에서 연결 역할**을 해야 합니다.

> **라우팅 과정 (패킷 전달 흐름) `교재와 다른 예시임`**

> 1️⃣ **출발지 장치(A)의 판단**
> - A는 B에게 패킷을 보내려고 하지만, 같은 네트워크(192.168.1.0/24)가 아닙니다.
> - A의 라우팅 테이블을 확인하고, 기본 게이트웨이(라우터 R1)로 패킷을 보내기로 결정합니다.
> - **A는 패킷의 목적지 IP를 192.168.2.20으로 설정한 후, 라우터 R1의 MAC 주소를 참조하여 패킷을 전송합니다.**

> 2️⃣ `라우터(R1)의 역할`
> - R1은 패킷을 받으면 먼저 `목적지 IP(192.168.2.20)`가 자신의 네트워크에 속해 있는지 확인합니다.
> - 확인 결과, 192.168.2.0/24 네트워크가 연결되어 있음을 라우팅 테이블에서 찾습니다.
> - 라우터는 **이 패킷을 어느 인터페이스(출구)로 보내야 할지 결정**합니다.
> - 192.168.2.20이 192.168.2.0/24 네트워크에 속해 있으므로 **해당 인터페이스로 패킷을 전달합니다.**

> 3️⃣ **패킷 도착 및 응답**
> - B는 패킷을 수신하고, 응답 패킷을 A에게 보내야 합니다.
> - B의 네트워크(192.168.2.0/24)에 속하지 않는 A(192.168.1.10)에게 직접 전송할 수 없으므로, B도 **라우터(R1)를 거쳐** A에게 응답을 보냅니다.
> - 위와 같은 과정이 반복되면서 A와 B는 통신할 수 있습니다.

![Image](https://github.com/user-attachments/assets/a13373ec-6e4a-4c4e-a883-f5dcc18cf776)
![Image](https://github.com/user-attachments/assets/7d329f29-c68b-4399-98bc-e340ad6b4cf5)
![Image](https://github.com/user-attachments/assets/41007ed1-82e4-450b-bd33-2cdd5f8f7282)
![Image](https://github.com/user-attachments/assets/d02ee33d-2bf6-471d-878e-6aa36b49a345)
---

### 4.3.2 **라우팅 테이블**

라우팅 테이블은 **라우터가 패킷을 목적지까지 전달하는 경로를 결정하는 데이터베이스**입니다.  
네트워크의 모든 라우터는 **라우팅 테이블을 기반으로 최적의 경로를 선택**하여 패킷을 전달합니다.

> ### **라우팅 테이블의 주요 항목**
> - **목적지 네트워크 (Destination Network)**: 패킷이 도달해야 하는 최종 네트워크 주소
> - **서브넷 마스크 (Subnet Mask)**: 네트워크와 호스트 부분을 구분하는 값
> - **게이트웨이 (Next Hop)**: 패킷을 다음으로 보낼 라우터의 IP 주소
> - **인터페이스 (Interface)**: 패킷이 나가는 포트 (예: Ethernet0, GigabitEthernet1 등)
> - **메트릭 (Metric)**: 여러 개의 경로가 있을 때 최적의 경로를 결정하는 우선순위 값 (낮을수록 우선순위 높음)

라우팅 테이블은 크게 `정적 라우팅(Static Routing)`과 `동적 라우팅(Dynamic Routing)`을 통해 관리됩니다.

---

> **정적 라우팅 (Static Routing)**

정적 라우팅은 **관리자가 직접 라우팅 테이블을 설정하는 방식**입니다.  
고정된 네트워크 환경에서 주로 사용되며, 네트워크 변경이 적은 환경에 적합합니다.
![Image](https://github.com/user-attachments/assets/cbe5ed72-5a99-4a01-a6b6-1b3904e2e88d)

> **정적 라우팅의 특징**
> - **수동 설정 필요**: 관리자가 직접 목적지 네트워크와 다음 홉(Next Hop)을 지정
> - **변경 시 직접 수정 필요**: 네트워크 변경이 발생하면 수동으로 업데이트해야 함
> - **CPU 부담 없음**: 라우터가 경로를 계산하지 않기 때문에 성능 부담이 적음
> - **보안성 높음**: 자동으로 경로가 변경되지 않으므로 보안이 강화됨

> **정적 라우팅 예제**
관리자가 **192.168.2.0/24 네트워크로 가는 경로**를 직접 설정한다고 가정합니다.

```plaintext
라우팅 테이블 예제:
--------------------------------------------------------
네트워크 주소  | 서브넷 마스크  | 게이트웨이   | 인터페이스 | 메트릭
--------------------------------------------------------
192.168.1.0   | 255.255.255.0 | 직접연결됨   |  Eth0 | 1
192.168.2.0   | 255.255.255.0 |192.168.1.1 | Eth1 | 5
--------------------------------------------------------
```
- **192.168.2.0/24 네트워크로 가려면, 192.168.1.1을 경유해야 함**
- 이 경로는 **관리자가 직접 설정해야 하며 자동으로 업데이트되지 않음**

> **정적 라우팅의 장점**  
> ✔ 작은 네트워크에서는 관리가 용이  
> ✔ 네트워크 성능을 최적화할 수 있음  
> ✔ 보안성이 높아 외부의 예기치 않은 경로 변경을 방지

> **정적 라우팅의 단점**  
> ❌ 네트워크가 변경되면 관리자가 직접 수정해야 함  
> ❌ 대규모 네트워크에서는 관리 부담이 커짐  
> ❌ 장애 발생 시 수동으로 우회 경로를 설정해야 함

---

> **동적 라우팅 (Dynamic Routing)**

동적 라우팅은 **라우터가 자동으로 네트워크 상태를 감지하고 최적의 경로를 설정하는 방식**입니다.  
대규모 네트워크에서는 **정적 라우팅을 일일이 관리하기 어렵기 때문에, 동적 라우팅이 필수적**입니다.
![Image](https://github.com/user-attachments/assets/ea42bd93-68f5-4c0d-ae3f-c6c6a32656fc)

> **동적 라우팅의 특징**
> - **라우터 간 자동 경로 학습**: 네트워크 변경 시 자동으로 경로를 업데이트
> - **최적의 경로 선택**: 경로 중단 또는 장애 발생 시 대체 경로를 자동으로 설정
> - **CPU 사용량 증가**: 라우터가 실시간으로 경로를 계산해야 하므로 성능 부담이 있음
    ![Image](https://github.com/user-attachments/assets/d44729cb-0361-4086-8e75-eaaf725c05a8)
#### 📌 **동적 라우팅 예제**
라우터가 RIP(Routing Information Protocol)를 사용하여 자동으로 경로를 학습한다고 가정합니다.
![Image](https://github.com/user-attachments/assets/29394fd8-6390-4aa9-b717-a5fb538354c9)

1. **RIP 프로토콜을 사용하여 라우터 간 네트워크 정보를 공유**
2. **라우터가 받은 정보를 기반으로 최적의 경로를 자동으로 설정**
3. **네트워크 변경이 발생하면 자동으로 새로운 경로를 계산하여 반영**
---

### 4.3.3 **라우팅 프로토콜**

라우팅 프로토콜은 **라우터들이 서로 정보를 주고받아 최적의 경로를 자동으로 설정하는 방법**입니다.  
네트워크 규모가 크거나 변경이 잦다면, **라우팅 프로토콜을 통해 경로를 자동으로 업데이트하는 것이 필수적**입니다.

라우팅 프로토콜은 크게 IGP(내부 라우팅)과 EGP(외부 라우팅)으로 나뉩니다.

| 프로토콜 유형 | 설명 | 예시 |
|--------------|------------------------------------|----------------|
| **IGP** (Interior Gateway Protocol) | 같은 조직 내부에서 사용되는 프로토콜 | RIP, OSPF, EIGRP |
| **EGP** (Exterior Gateway Protocol) | ISP(인터넷 서비스 제공업체) 및 대형 네트워크 간 통신을 담당 | BGP |


---

> **RIP, OSPF, EIGRP 비교**

라우팅 프로토콜마다 경로를 결정하는 방식과 특징이 다릅니다.  
가장 많이 사용되는 IGP(내부 라우팅 프로토콜) 3가지의 차이를 비교하면 다음과 같습니다.

| 라우팅 프로토콜 | 방식 | 주요 특징 |
|--------------|------------------|----------------------------|
| **RIP** | 거리 벡터 방식 | 홉 수를 기준으로 경로 선택, 최대 15홉 제한 |
| **OSPF** | 링크 상태 방식 | 네트워크 전체 정보를 참고하여 최적 경로 선택 |
| **EIGRP** | 하이브리드 방식 | 거리 벡터 & 링크 상태 혼합, 빠른 수렴 속도 |

> ### **RIP (Routing Information Protocol)**
> ![Image](https://github.com/user-attachments/assets/134d87c2-3aa2-4f39-b17f-45ef81540853)
> - 가장 오래된 라우팅 프로토콜 중 하나
> - 홉 수(경유하는 라우터 개수)가 가장 적은 경로를 선택
> - **최대 15홉까지만 가능**하여 대규모 네트워크에는 부적합
> - IPv6에서는 `RIPng(RIP next generation)`을 사용

> ### **OSPF (Open Shortest Path First)**
> ![Image](https://github.com/user-attachments/assets/53e99ccf-050e-4048-867c-98e90d184e9e)
> - 네트워크 전체 정보를 수집하여 **최적의 경로를 계산**
> - 홉 수가 아닌 **대역폭과 지연시간을 고려**하여 경로를 결정
> - 중~대규모 네트워크에서 널리 사용됨
> - IPv6에서는 **OSPFv3** 사용

> ### **EIGRP (Enhanced Interior Gateway Routing Protocol)**
> ![Image](https://github.com/user-attachments/assets/cac1f327-dacb-4cc7-8be7-1e47cee7184a)
> - Cisco에서 개발한 독자적인 라우팅 프로토콜
> - 거리 벡터 방식과 링크 상태 방식을 혼합하여 사용
> - **빠른 수렴 속도**와 **다양한 네트워크 조건 반영 가능**
> - IPv6에서도 사용 가능 (EIGRP for IPv6)
---
>  **EGP의 대표 프로토콜: BGP**
![Image](https://github.com/user-attachments/assets/18c81007-c755-40f2-9c52-9c8a8b2ff843)
EGP(Exterior Gateway Protocol)는 **조직 간 또는 인터넷 규모의 네트워크에서 사용되는 라우팅 프로토콜**입니다.  
그중에서도 가장 대표적인 프로토콜이 `BGP(Border Gateway Protocol)`이며,  
BGP는 **인터넷의 기본 라우팅 프로토콜**로 사용되고 있습니다.

> ### **BGP의 특징**
> - **AS(Autonomous System) 간의 경로를 설정**
> - **전 세계 인터넷 경로를 관리하는 역할**
> - **최적의 경로를 선택하여 패킷을 전달**
> - **라우터 간 안정적인 연결을 유지하기 위해 TCP를 사용**

BGP는 인터넷을 구성하는 개별 네트워크(AS) 간 **라우팅 정보를 교환하는 역할**을 합니다.  
즉, **인터넷을 통해 데이터를 목적지까지 가장 효율적으로 보낼 수 있도록 경로를 결정하는 핵심 프로토콜**입니다.

---

### 4.3.3.1 **BGP의 핵심 개념: AS 번호**

인터넷에서 BGP를 사용할 때, 각 조직(네트워크)은 고유한 `AS 번호(ASN, Autonomous System Number)`를 할당받습니다.  
AS 번호는 **전 세계적으로 고유**하며, 인터넷 상에서 라우팅을 수행하는 네트워크를 식별하는 역할을 합니다.

> **AS 번호의 구조**
> - **0번, 65535번**: 예약된 번호
> - **1~64511번**: 글로벌 AS 번호 (ICANN에서 관리)
> - **64512~65534번**: 프라이빗 AS 번호 (7내부 네트워크에서 사용)

BGP는 AS 번호를 기반으로 **각 네트워크 간의 연결 관계를 설정**하고,  
이 정보를 통해 패킷이 이동할 최적의 경로를 결정합니다.

---

### 4.3.3.2 **BGP의 동작 방식**

BGP는 단순히 목적지까지의 홉 수만 따지는 것이 아니라,  
**경로의 안정성, 정책, 지연 시간 등을 종합적으로 고려하여 최적의 경로를 결정**합니다.

> ### **BGP의 경로 선택 과정**
> 1. **BGP 피어(Peer) 형성**
     >    - BGP를 실행하는 라우터는 `이웃 라우터(BGP 피어)`와 연결을 설정
>    - 피어 간의 BGP 테이블을 공유하며, 경로 정보를 교환
> 2. **경로 학습 및 업데이트**
     >    - BGP는 지속적으로 **이웃 라우터로부터 경로 정보를 업데이트**
>    - 변경이 발생하면 해당 정보를 전체 네트워크에 전파
> 3. **최적의 경로 선택**
     >    - 여러 개의 경로가 존재할 경우, BGP 알고리즘을 사용하여 최적의 경로를 결정
> 4. **패킷 전달**
     >    - 최적의 경로를 선택한 후, 패킷을 해당 경로를 따라 전달


---

### 4.3.3.3 **BGP의 최적 경로 선택 알고리즘**
> ### **BGP 경로 선택 기준**
> ![Image](https://github.com/user-attachments/assets/bbd1050f-00fc-4a55-b25a-5a8dda199eba)
> - **NEXT_HOP**: 패킷이 도착할 수 있는 유효한 경로인지 확인
> - **WEIGHT**: 특정 경로에 우선순위를 부여 (Cisco 전용)
> - **LOCAL_PREF**: AS 내부에서 특정 경로를 우선적으로 선택
> - **AS_PATH**: 경로를 지나온 AS 개수를 비교하여 짧은 경로를 우선
> - **ORIGIN**: 경로 정보를 얻은 방식에 따라 우선순위 결정
> - **MED**: 동일 목적지에 대한 여러 개의 경로 중 선호 경로 설정

이러한 기준을 바탕으로 **가장 효율적인 경로**가 BGP 테이블에 등록되며,  
인터넷의 수많은 경로를 최적으로 유지할 수 있습니다.
![Image](https://github.com/user-attachments/assets/33d00138-22e3-4fb0-8c72-77c2f29abc0f)

---

## 4.3.4 **라우팅 재전송 (Redistribution)**
![Image](https://github.com/user-attachments/assets/ff8c54b0-520d-4dc6-b21b-5f9fa1aa8543)

일반적으로 네트워크에서는 여러 가지 라우팅 프로토콜이 동시에 사용됩니다.  
예를 들어, **회사 내부에서는 OSPF를 사용하고, 외부 네트워크와 연결할 때는 BGP를 사용할 수 있습니다.**

이처럼 **서로 다른 라우팅 프로토콜을 함께 사용할 경우, 라우팅 정보를 변환하여 전달하는 과정이 필요**합니다.  
이 과정을 `라우팅 재전송(Redistribution)`라고 합니다.

> **라우팅 재전송의 예시**
> - OSPF로 학습한 네트워크 정보를 BGP로 전달
> - EIGRP에서 학습한 정보를 RIP로 변환하여 공유

라우팅 재전송을 통해 **다양한 라우팅 프로토콜 간의 원활한 연동이 가능**하며,  
복잡한 네트워크 환경에서도 일관된 라우팅 정책을 유지할 수 있습니다.

---

### 4.3.5 **라우팅 테이블 규칙**

라우팅 테이블은 **네트워크에서 경로를 설정하는 핵심 데이터베이스**이며,  
라우터는 이 테이블을 기반으로 **패킷을 어떤 경로로 보낼지 결정**합니다.

> ### **라우팅 테이블의 주요 규칙**
> - **롱기스트 매치(Longest Match)**: 가장 구체적인 서브넷 마스크를 가진 경로를 우선 선택
> ![Image](https://github.com/user-attachments/assets/313f8bea-7835-40e1-b6f1-54c9a53b1326)
> ![Image](https://github.com/user-attachments/assets/d97cee8e-a2a6-46c9-ae3f-0ab42ccd7ee0)
> - **경로 집약(Route Aggregation)**: 여러 개의 경로를 하나의 범위로 묶어 테이블 크기를 줄임
> ![Image](https://github.com/user-attachments/assets/3043b17a-e46a-4ded-ab8c-29d9c9ca65b2)
> - **AD(Administrative Distance) 값**: 같은 목적지에 대해 여러 개의 경로가 있을 경우, 신뢰도가 높은 경로를 선택
> ![Image](https://github.com/user-attachments/assets/dbea6cb8-57fc-455a-9f5e-14d0c71b22a7)


#### 📌 **롱기스트 매치 예제**
라우터가 다음과 같은 경로를 가지고 있다고 가정합니다.

| 네트워크 주소 | 넷마스크 | 넥스트 홉 |
|--------------|---------|-----------|
| 192.168.0.0  | /16     | 1.1.1.1   |
| 192.168.1.0  | /24     | 1.1.1.2   |
| 192.168.1.128| /25     | 1.1.1.3   |

- 목적지가 **192.168.1.150**이라면?
    - **192.168.1.128/25**가 가장 구체적인 경로이므로 해당 경로를 선택

즉, **서브넷 마스크가 더 길수록(더 구체적일수록) 높은 우선순위를 가집니다.**

---

> **AD 값 (Administrative Distance)**

라우팅 테이블에서 같은 목적지에 대해 여러 개의 경로가 있을 경우,  
라우터는 `AD 값(Administrative Distance)`을 사용하여 신뢰도가 높은 경로를 선택합니다.

> **AD 값이 낮을수록 신뢰도가 높음**
> - **AD 값 0**: 직접 연결된 경로 (가장 신뢰도 높음)
> - **AD 값 1**: 정적 라우팅
> - **AD 값 90**: EIGRP
> - **AD 값 110**: OSPF
> - **AD 값 120**: RIP

라우터는 이러한 AD 값을 기반으로 **가장 신뢰할 수 있는 경로를 우선적으로 사용**하며,  
네트워크가 변화하면 새로운 경로를 동적으로 반영하여 최적의 연결을 유지합니다.

---

## 4.3.6 **VRF (Virtual Routing and Forwarding)**
![Image](https://github.com/user-attachments/assets/d3358cf6-06cf-45ef-bf9d-440d4cea38e5)
VRF(Virtual Routing and Forwarding)는 **하나의 라우터 내에서 여러 개의 독립적인 라우팅 테이블을 운영할 수 있도록 하는 기술**입니다.  
즉, **하나의 물리적 라우터가 마치 여러 개의 가상 라우터처럼 동작**할 수 있습니다.

> ### **VRF의 특징**
> - **각 네트워크 간의 라우팅 정보를 완전히 분리할 수 있음**
> - **하나의 라우터에서 여러 개의 고객망을 독립적으로 운영 가능**
> - **VPN과 결합하여 보안성을 높일 수 있음**
> - **라우터의 효율적인 리소스 활용이 가능**

VRF는 **VLAN과 개념이 유사하지만, Layer 3에서 동작하는 것이 차이점**입니다.  
일반적인 VLAN은 Layer 2에서 네트워크를 논리적으로 구분하는 반면,  
VRF는 **라우팅 테이블까지 분리**하여 완전한 네트워크 격리를 제공합니다.

> ### **VRF의 활용 예시**
> - **서비스 제공업체(ISP)가 여러 고객의 네트워크를 동일한 라우터에서 운영할 때**
> - **기업 내부에서 부서별로 독립적인 네트워크를 유지할 때**
> - **MPLS VPN과 함께 사용하여 보안이 강화된 네트워크를 구축할 때**

VRF를 활용하면 **보안과 네트워크 분리가 필요한 환경에서 더욱 효과적인 운영이 가능**합니다.

---

## 4.3.7 **정책 기반 라우팅 (Policy Based Routing, PBR)**
![Image](https://github.com/user-attachments/assets/2554d3d7-bdd2-4aad-abd1-2801d21b7bdc)

일반적인 라우팅 방식은 **목적지 IP 주소를 기준으로 경로를 결정**합니다.  
그러나 정책 기반 라우팅(PBR, Policy Based Routing)은 **트래픽의 특성(출발지, 애플리케이션 유형 등)에 따라 경로를 다르게 설정하는 방식**입니다.

> ### **정책 기반 라우팅의 특징**
> - **목적지 주소뿐만 아니라 다양한 기준으로 경로를 선택 가능**
> - **QoS(Quality of Service)와 함께 사용하여 특정 트래픽을 우선 처리 가능**
> - **ISP를 이중화하여 특정 트래픽을 특정 ISP로 보내는 정책 구현 가능**
> - **기업에서 부서별 인터넷 트래픽을 다르게 설정하는 데 활용 가능**

> ### **정책 기반 라우팅의 활용 예시**
> - **VoIP 트래픽을 전용선으로 우선 처리하고 일반 트래픽은 공유 네트워크 사용**
> - **업무용 트래픽과 엔터테인먼트 트래픽(유튜브, 넷플릭스 등)을 별도 경로로 분리**
> - **특정 애플리케이션(예: ERP 시스템) 트래픽을 보장된 네트워크 경로로 전달**

PBR을 활용하면 **기업 네트워크에서 트래픽을 보다 유연하게 제어할 수 있으며,  
네트워크 품질과 보안을 동시에 강화하는 데 효과적인 방식**입니다.

---

## 4.4 **IP 주소 할당 방법**

네트워크에서는 **각 장치(PC, 서버, 네트워크 장비 등)에 고유한 IP 주소를 부여**해야 합니다.  
IP 주소를 할당하는 방법은 크게 `정적 할당(Static Allocation)`과 `동적 할당(Dynamic Allocation)`으로 나뉩니다.

> ### **정적 할당 vs 동적 할당**
> - **정적 할당**: 관리자가 직접 IP 주소를 설정하는 방식
> - **동적 할당**: DHCP 등을 이용해 네트워크 장치가 자동으로 IP를 받는 방식

각 방식의 특징과 활용 방안을 자세히 살펴보겠습니다.

---

### 4.4.1 **정적 할당 (Static Allocation)**
![Image](https://github.com/user-attachments/assets/f6f98e97-ad7b-4430-b174-5532eee74916)

정적 할당이란 **IP 주소를 네트워크 관리자 또는 사용자가 직접 설정하는 방식**입니다.  
이 방식은 주로 **고정된 서버, 프린터, 네트워크 장비 등에서 사용**됩니다.

> ### **정적 할당의 특징**
> - **IP 주소가 고정되므로 장기적인 안정성 제공**
> - **네트워크 관리자가 수동으로 설정해야 하므로 대규모 네트워크에서는 비효율적**
> - **IP 충돌 가능성이 있으므로 철저한 관리 필요**

> **정적 할당이 필요한 경우**
> - 서버(웹 서버, DB 서버 등)
> - 네트워크 장비(라우터, 스위치)
> - 프린터 등 특정 장비

정적 할당 방식은 **소규모 네트워크에서는 유용하지만,  
대규모 환경에서는 IP 관리의 어려움 때문에 주로 동적 할당 방식이 사용됩니다.**

---

### 4.4.2 **동적 할당 (Dynamic Allocation)**
![Image](https://github.com/user-attachments/assets/b837a663-dde2-4884-95f0-beb182a583af)

동적 할당 방식은 **DHCP(Dynamic Host Configuration Protocol)를 통해 IP 주소를 자동으로 설정**하는 방법입니다.  
이 방식은 **PC, 스마트폰, IoT 기기 등 대량의 장치에 자동으로 IP 주소를 할당**하는 데 사용됩니다.

> ### **동적 할당의 특징**
> - **IP 주소를 자동으로 할당하므로 관리가 편리**
> - **장치가 추가되거나 변경될 때 유연한 IP 주소 할당 가능**
> - **일정 기간(IP 임대 기간) 후 새로운 IP 주소를 할당할 수도 있음**

> **동적 할당이 필요한 경우**
> - 대규모 사무실, 학교, 공공 네트워크
> - Wi-Fi 환경 (스마트폰, 노트북, 태블릿 등)
> - IP를 일일이 수동 설정할 필요가 없는 환경

---

### 4.4.3 **DHCP (Dynamic Host Configuration Protocol)**

DHCP는 **네트워크에서 IP 주소를 자동으로 할당하고 관리하는 프로토콜**입니다.  
네트워크 내에서 **DHCP 서버가 IP 주소를 중앙에서 관리**하며, 장치가 네트워크에 연결될 때  
자동으로 적절한 IP를 부여합니다.

> ### **DHCP 동작 과정**
> 1. **DHCP Discover**: 클라이언트가 DHCP 서버를 찾기 위해 브로드캐스트 전송
> 2. **DHCP Offer**: DHCP 서버가 사용 가능한 IP 주소를 응답
> 3. **DHCP Request**: 클라이언트가 특정 IP를 요청
> 4. **DHCP ACK**: DHCP 서버가 IP 주소를 최종적으로 할당

DHCP는 **자동화된 IP 주소 관리가 필요한 환경에서 필수적인 기술**입니다.

---
> **IPv4에서의 동적 할당**

![Image](https://github.com/user-attachments/assets/e37551a3-8a16-4efc-b21c-7c5d2c4ab56b)

IPv4에서 **자동으로 IP 주소를 할당하는 방식**은 **DHCPv4**를 통해 이루어집니다.  
DHCPv4는 **서버가 클라이언트에게 IP 주소, 서브넷 마스크, 게이트웨이, DNS 설정 등을 자동으로 제공**하는 프로토콜입니다.

> ### **DHCPv4의 특징**
> - 클라이언트가 IP 주소를 직접 설정할 필요 없음
> - 일정 시간이 지나면 **IP 임대 기간이 만료되고, 새로운 IP가 자동으로 재할당**
> - 브로드캐스트(255.255.255.255)와 **유니캐스트를 함께 사용하여 IP 주소를 교환**

---

> ### **DHCPv4 동작 과정**
> 1️⃣ **클라이언트가 IP 주소 요청**
>    - 네트워크에 처음 연결된 장치가 **DHCP Discover** 메시지를 브로드캐스트 전송
>
> 2️⃣ **DHCP 서버가 사용 가능한 IP 주소를 제공**
>    - **DHCP Offer** 메시지를 클라이언트에게 응답 (이때 유니캐스트 사용)
>
> 3️⃣ **클라이언트가 특정 IP를 요청**
>    - **DHCP Request** 메시지를 보내 해당 IP를 사용할 의사를 서버에 전달
>
> 4️⃣ **DHCP 서버가 최종적으로 IP를 할당**
>    - **DHCP ACK** 메시지를 통해 IP 설정을 완료 <br>
> 

---
<br><br><br>

> **IPv6에서의 동적 할당 (SLAAC & DHCPv6)**

IPv6에서는 `SLAAC(Stateless Address Auto Configuration)`과 **DHCPv6** 두 가지 방식으로 동적 할당이 이루어집니다.

> **SLAAC**
> ![Image](https://github.com/user-attachments/assets/c22d4fc9-10f7-4e22-b4a2-d16d28d23690)
> - 네트워크 장비가 `라우터 광고 메시지(RA, Router Advertisement)`를 기반으로 자동으로 IP 주소를 생성
> - **DHCP 서버 없이도 IP 주소 설정 가능**
> - **일반 가정 및 소규모 네트워크에서 활용**

> **DHCPv6**
> ![Image](https://github.com/user-attachments/assets/7c0a7b3f-2406-4d3a-b8f6-f7dd5f25fc4d)
> - **IPv6 네트워크에서도 DHCP를 사용하여 중앙 집중식 IP 주소 관리 가능**
> - **라우터가 아니라 별도의 DHCPv6 서버가 필요**
> - **대규모 네트워크 및 기업 환경에서 사용됨**

IPv6에서는 **SLAAC 방식이 기본적으로 제공되지만,  
보다 정교한 IP 주소 관리를 위해 DHCPv6를 사용하는 경우가 많습니다.**
---

### 4.4.3 **DHCP 릴레이 에이전트**

DHCP는 DHCPv4, DHCPv6에 관계없이 모두 **클라이언트와 서버가 같은 네트워크(VLAN, 브로드캐스트 도메인) 내에서 동작**하는 것을 기본 원칙으로 합니다.  
하지만 기업이나 ISP 환경에서는 **여러 개의 네트워크가 존재하기 때문에**  
각 네트워크마다 DHCP 서버를 따로 두는 것은 현실적으로 어렵습니다.

이를 해결하기 위해 `DHCP 릴레이 에이전트(DHCP Relay Agent)`가 사용됩니다.

![Image](https://github.com/user-attachments/assets/5d8583c9-95b5-4b49-aafb-8efe35215b3d)

> ### **DHCP 릴레이 에이전트의 역할**
> - DHCP 클라이언트가 보내는 **브로드캐스트 패킷을 유니캐스트로 변환**하여 DHCP 서버로 전달
> - 서버가 응답한 IP 주소 정보를 다시 클라이언트에게 전송
> - 여러 네트워크가 존재하는 환경에서 **단일 DHCP 서버로 전체 네트워크 관리 가능**

---

> ### **DHCP 릴레이 에이전트 동작 과정**
> 1️⃣ **클라이언트가 IP 주소 요청**
>    - DHCP Discover 메시지를 브로드캐스트(255.255.255.255)로 전송
>    - 같은 서브넷에 DHCP 서버가 없으면 DHCP 릴레이 에이전트가 이를 수신
>
> 2️⃣ **DHCP 릴레이 에이전트가 패킷을 DHCP 서버로 전달**
>    - 브로드캐스트 패킷을 **유니캐스트로 변환**하여 원격 DHCP 서버로 전송
>
> 3️⃣ **DHCP 서버가 IP 주소를 할당하여 응답**
>    - DHCP Offer 메시지를 생성하여 릴레이 에이전트에게 전달
>
> 4️⃣ **릴레이 에이전트가 클라이언트에게 응답 전달**
>    - DHCP Offer 메시지를 브로드캐스트 방식으로 다시 클라이언트에게 전송
>    - 이후 DHCP Request 및 DHCP ACK 과정이 동일하게 진행

---
